var roomName;
var v;
module.exports.loop = function () {
    if(Game.cpu.bucket < 400){
        return console.log(Game.cpu.bucket)
    }
    if(!Game.getObjectById(Memory.spawnID)){
        v = false;
        Memory.spawnID = Game.spawns['Spawn1'].id;
        Memory.roomName = Object.keys(Game.rooms)[0];
    }
    roomName = Memory.roomName;
    InitGame();
    if(!v)NN(roomName);
    else VisualBuilding();
    console.log('消耗CPU:' + Game.cpu.getUsed())
    
}
function InitGame(){
    if(!Memory.rooms){
        Memory.rooms = {};
    }
    if(!Memory.rooms[roomName]){
        for(let name in Memory.rooms){
            if(!Game.rooms[name]){
                delete Memory.rooms[name];
            }
        }
        Memory.rooms[roomName] = {};
        Memory.rooms[roomName]['buildings'] = {};
    }
}
function NN(){
    //房间
    let room = Game.rooms[roomName];
    let controller = Game.rooms[roomName].controller;
    let sources = room.find(FIND_SOURCES);
    let mineralPos = room.find(FIND_MINERALS)[0].pos;
    //绘制缓存
    let visual = new RoomVisual(roomName);
    //地形
    const terrain = new Room.Terrain(roomName);
    //对比costs
    let costs = new PathFinder.CostMatrix;
    //建筑cost
    let buildingCosts = new PathFinder.CostMatrix;
    //建筑缓存,初始化
    let buildingsObject = {};
    buildingsObject['spawn'] = {};
    buildingsObject['tower'] = {};
    buildingsObject['factory'] = {};
    buildingsObject['nuker'] = {};
    buildingsObject['container'] = {};
    buildingsObject['lab'] = {};
    buildingsObject['terminal'] = {};
    buildingsObject['extractor'] = {};
    buildingsObject['powerSpawn'] = {};
    buildingsObject['observer'] = {};
    buildingsObject['storage'] = {};
    buildingsObject['rampart'] = {};
    buildingsObject['constructedWall'] = {};
    buildingsObject['road'] = {};
    buildingsObject['link'] = {};
    buildingsObject['extension'] = {};
    //地形导入建筑缓存
    for(let x = 0;x < 50;x++){
        for(let y = 0;y < 50;y++){
            let type = terrain.get(x,y);
            buildingCosts.set(x,y,type == 0 ? 2 : type == 1 ? 255 : 10);
        }
    }
    //找中心区域（cost=250为第一层可作为中心区的位置，3格[5*5]内没有地形墙）
    
    let center_1 = [];
    for(let terrain_x = 2;terrain_x < 48;terrain_x++){
        for(let terrain_y = 2;terrain_y < 48;terrain_y++){
            let node_value = 0;
            for(let x = terrain_x - 2;x <= terrain_x + 2;x++){
                for(let y = terrain_y - 2;y <= terrain_y + 2;y++){
                    let type = terrain.get(x,y);
                    if(type != 1){
                        node_value += 10;
                    }
                }
            }
            if(node_value == 250){
                if(terrain_x >= 42 || terrain_x <= 7 || terrain_y >= 42 || terrain_y <= 7){
                    continue;
                }
                costs.set(terrain_x,terrain_y,250);
                center_1.push([terrain_x,terrain_y])
            }
        }
    }
    let center1 = [0,0,50];
    for(let center of center_1){
        let x = center[0];
        let y = center[1];
        if(DM_XY_Distence(x,y,controller.pos.x,controller.pos.y) <= 4)continue;
        let f = 0;
        if(terrain.get(x - 2,y - 3) == 1 || terrain.get(x - 3,y - 2) == 1){
            if(terrain.get(x + 2,y + 3) == 1 || terrain.get(x + 3,y + 2) == 1){
                f++;
            }
            if(terrain.get(x - 2,y + 3) == 1 || terrain.get(x - 3,y + 2) == 1){
                f++;
            }
            if(terrain.get(x + 2,y - 3) == 1 || terrain.get(x + 3,y - 2) == 1){
                f++;
            }
        }
        if(f > 0){
            continue;
        }
        f = 0;
        if(terrain.get(x + 2,y - 3) == 1 || terrain.get(x + 3,y - 2) == 1){
            if(terrain.get(x + 2,y + 3) == 1 || terrain.get(x + 3,y + 2) == 1){
                f++;
            }
            if(terrain.get(x - 2,y + 3) == 1 || terrain.get(x - 3,y + 2) == 1){
                f++;
            }
            if(terrain.get(x - 2,y - 3) == 1 || terrain.get(x - 3,y - 2) == 1){
                f++;
            }
        }
        if(f > 0){
            continue;
        }
        f = 0;
        if(terrain.get(x - 2,y + 3) == 1 || terrain.get(x - 3,y + 2) == 1){
            if(terrain.get(x + 2,y + 3) == 1 || terrain.get(x + 3,y + 2) == 1){
                f++;
            }
            if(terrain.get(x - 2,y - 3) == 1 || terrain.get(x - 3,y - 2) == 1){
                f++;
            }
            if(terrain.get(x + 2,y - 3) == 1 || terrain.get(x + 3,y - 2) == 1){
                f++;
            }
        }
        if(f > 0){
            continue;
        }
        f = 0;
        if(terrain.get(x + 2,y + 3) == 1 || terrain.get(x + 3,y + 2) == 1){
            if(terrain.get(x - 2,y - 3) == 1 || terrain.get(x - 3,y - 2) == 1){
                f++;
            }
            if(terrain.get(x - 2,y + 3) == 1 || terrain.get(x - 3,y + 2) == 1){
                f++;
            }
            if(terrain.get(x + 2,y - 3) == 1 || terrain.get(x + 3,y - 2) == 1){
                f++;
            }
        }
        if(f > 0){
            continue;
        }
        f = 0;
        for(let cx = x - 1;cx <= x + 1;cx++){
            for(let cy = y - 1;cy <= y + 1;cy++){
                let cost = costs.get(cx,cy);
                if(cost == 250){
                    f++;
                }
                if(f >= 4)break;
            }
            if(f >= 4)break;
        }
        if(f >= 4){
            let length = DM_XY_Distence(x,y,controller.pos.x,controller.pos.y);
            if(length < center1[2]){
                center1 = [x,y,length];
            }
        }
    }
    if(center1[2] == 50){
        return console.log('中心布局失败')
    }
    //过滤中心区域（cost=251为第二层可作为中心的位置，1格[3*3]内cost=250）
    let center_2 = [];
    for(let center of center_1){
        let terrain_x = center[0];
        let terrain_y = center[1];
        if(controller.pos.getRangeTo(terrain_x,terrain_y) <= 5){
            continue;
        }
        let f = true;
        for(let x = terrain_x - 1;x <= terrain_x + 1;x++){
            for(let y = terrain_y - 1;y <= terrain_y + 1;y++){
                if(costs.get(x,y) == 0){
                    f = false;
                    break;
                }
            }
            if(!f)break;
        }
        if(!f)continue;
        if(PathFinder.search(
            new RoomPosition(terrain_x,terrain_y,roomName),
            {pos : controller.pos,range : 1}
        ).path.length >= 20)continue;
        costs.set(terrain_x,terrain_y,251);
        center_2.push([terrain_x,terrain_y])
    }
    let length_min_0 = [0,0,50];
    {
        let lengths = [];
        for(let center of center_2){
            let length = controller.pos.getRangeTo(center[0],center[1]);
            if(length >= 15 || length < 5 || center[0] <= 7 || center[1] <= 7 || center[0] >= 42 || center[1] >= 42){
                costs.set(center[0],center[1],250);
                continue;
            }
            lengths.push([center[0],center[1],length]);
        }
        if(lengths.length > 0){
            let lengths_ = [];
            for(let length of lengths){
                let x = length[0];
                let y = length[1];
                if((costs.get(x + 1,y) == 250 && costs.get(x - 1,y) == 250) || (costs.get(x,y + 1) == 250 && costs.get(x,y - 1) == 250)){
                    costs.set(x,y,250);
                    continue;
                }
                lengths_.push(length);
            }
            for(let length of lengths_){
                let l = DM_XY_Distence(length[0],length[1],controller.pos.x,controller.pos.y,true);
                if(l < length_min_0[2]){
                    length_min_0 = [length[0],length[1],l]
                }
            }
        }
    }
    
    //过滤中心区域（cost=252为第三层，一格内[3*3]cost=251）
    for(let center of center_2){
        let terrain_x = center[0];
        let terrain_y = center[1];
        if(controller.pos.getRangeTo(terrain_x,terrain_y) <= 5){
            continue;
        }
        let f = true;
        for(let x = terrain_x - 1;x <= terrain_x + 1;x++){
            for(let y = terrain_y - 1;y <= terrain_y + 1;y++){
                if(costs.get(x,y) == 250){
                    f = false;
                    break;
                }
            }
            if(!f)break;
        }
        if(!f)continue;
        if(PathFinder.search(
            new RoomPosition(terrain_x,terrain_y,roomName),
            {pos : controller.pos,range : 1},
            {
                plainCost : 2,
                swampCost : 2
            }
        ).path.length >= 15)continue;
        costs.set(terrain_x,terrain_y,252);
    }
    let length_min_1 = [0,0,50];
    {
        let lengths = [];
        let controller = Game.rooms[roomName].controller;
        for(let terrain_x = 2;terrain_x < 48;terrain_x++){
            for(let terrain_y = 2;terrain_y < 48;terrain_y++){
                if(costs.get(terrain_x,terrain_y) == 252){
                    let length = controller.pos.getRangeTo(terrain_x,terrain_y)
                    if(length >= 15 || length < 5 || terrain_x <= 7 || terrain_y <= 7 || terrain_x >= 42 || terrain_y >= 42){
                        costs.set(terrain_x,terrain_y,251);
                        continue;
                    }
                    lengths.push([terrain_x,terrain_y,length]);
                }
            }
        }
        if(lengths.length > 0){
            let lengths_ = [];
            for(let length of lengths){
                let x = length[0];
                let y = length[1];
                if((costs.get(x + 1,y) == 251 && costs.get(x - 1,y) == 251) || (costs.get(x,y + 1) == 251 && costs.get(x,y - 1) == 251)){
                    costs.set(x,y,251);
                    continue;
                }
                lengths_.push(length);
            }
            for(let length of lengths_){
                let l = DM_XY_Distence(length[0],length[1],controller.pos.x,controller.pos.y,true);
                if(l < length_min_1[2]){
                    length_min_1 = [length[0],length[1],l]
                }
            }
        }
    }
    //选择层级
    Visual(costs);
    
    //调整中心位置
    let median = [length_min_1[0],length_min_1[1]];
    let spare = false;
    if(length_min_0[2] == 50 && length_min_1[2] == 50){
        if(center1[2] == 50){
            return console.log('中心布局失败');
        }else{
            spare = true;
            median = [center1[0],center1[1]];
        }
    }
    if(!spare){
        let changeMedian = 0;
        if(length_min_1[2] < 50){
            let centerTransform = [[median[0] + 6,median[1]],[median[0] - 6,median[1]],[median[0],median[1] + 6],[median[0],median[1] - 6]]
            let center_length = [];
            for(let center of centerTransform){
                let x = center[0];
                let y = center[1];
                center_length.push(terrain.get(x,y) == 1 ? DM_XY_Distence((median[0] + x) / 2,(median[1] + y) / 2,controller.pos.x,controller.pos.y) : 50);
            }
            let min = 50;
            for(let length of center_length){
                if(length < min){
                    min = length;
                }
            }
            if(min != 50){
                let center = centerTransform[center_length.indexOf(min)];
                median[0] = ((median[0] + center[0]) / 2) > median[0] ? median[0] += changeMedian : median[0] -= changeMedian;
                median[1] = ((median[1] + center[1]) / 2) > median[1] ? median[1] += changeMedian : median[1] -= changeMedian;
            }
        }else{
            median = [length_min_0[0],length_min_0[1]];
            let centerTransform = [[median[0] + 6,median[1]],[median[0] - 6,median[1]],[median[0],median[1] + 6],[median[0],median[1] - 6]]
            let center_length = [];
            for(let center of centerTransform){
                let x = center[0];
                let y = center[1];
                center_length.push(terrain.get(x,y) == 1 ? DM_XY_Distence((median[0] + x) / 2,(median[1] + y) / 2,controller.pos.x,controller.pos.y) : 50);
            }
            let min = 50;
            for(let length of center_length){
                if(length < min){
                    min = length;
                }
            }
            if(min != 50){
                let center = centerTransform[center_length.indexOf(min)];
                median[0] = ((median[0] + center[0]) / 2) > median[0] ? median[0] += changeMedian : median[0] -= changeMedian;
                median[1] = ((median[1] + center[1]) / 2) > median[1] ? median[1] += changeMedian : median[1] -= changeMedian;
            }
        }
    }
    //中心布局
    let center_energy = [];
    {
        let x = center_energy[0] = median[0];
        let y = center_energy[1] = median[1];
        for(let cx = x - 2;cx <= x + 2;cx++){
            for(let cy = y - 2;cy <= y + 2;cy++){
                buildingCosts.set(cx,cy,255);
            }
        }
        buildingsObject['extension'][(x - 2) + '/' + (y - 1)] = 1;
        buildingsObject['extension'][(x - 1) + '/' + y] = 1;
        buildingsObject['extension'][x + '/' + (y - 1)] = 1;
        buildingsObject['extension'][(x + 1) + '/' + y] = 1;
        buildingsObject['extension'][(x + 2) + '/' + (y - 1)] = 1;
        buildingsObject['spawn'][x + '/' + (y - 2)] = 1;
        buildingsObject['rampart'][x + '/' + (y - 2)] = 6;

        buildingsObject['extension'][(x - 2) + '/' + (y - 2)] = 2;
        buildingsObject['extension'][(x - 1) + '/' + (y - 2)] = 2;
        buildingsObject['extension'][(x + 1) + '/' + (y - 2)] = 2;
        buildingsObject['extension'][(x + 2) + '/' + (y - 2)] = 2;
        buildingsObject['extension'][x + '/' + (y + 1)] = 2;

        buildingsObject['extension'][(x - 2) + '/' + (y + 1)] = 3;
        buildingsObject['extension'][(x - 2) + '/' + (y + 2)] = 3;
        buildingsObject['extension'][(x - 1) + '/' + (y + 2)] = 3;
        buildingsObject['extension'][(x + 1) + '/' + (y + 2)] = 3;
        buildingsObject['extension'][(x + 2) + '/' + (y + 2)] = 3;
        buildingsObject['extension'][(x + 2) + '/' + (y + 1)] = 3;

        let road_left = x - 3;
        for(let terrain_y = y - 2;terrain_y <= y + 2;terrain_y++){
            if(terrain.get(road_left,terrain_y) != 1){
                buildingsObject['road'][road_left + '/' + terrain_y] = 3;
            }
        }

        let road_right = x + 3;
        for(let terrain_y = y - 2;terrain_y <= y + 2;terrain_y++){
            if(terrain.get(road_right,terrain_y) != 1){
                buildingsObject['road'][road_right + '/' + terrain_y] = 3;
            }
        }
        
        let road_up = y - 3;
        for(let terrain_x = x - 2;terrain_x <= x + 2;terrain_x++){
            if(terrain.get(terrain_x,road_up) != 1){
                buildingsObject['road'][terrain_x + '/' + road_up] = 3;
            }
        }
        
        let road_down = y + 3;
        for(let terrain_x = x - 2;terrain_x <= x + 2;terrain_x++){
            if(terrain.get(terrain_x,road_down) != 1){
                buildingsObject['road'][terrain_x + '/' + road_down] = 3;
            }
        }

        buildingsObject['container'][(x - 2) + '/' + y] = 3;
        buildingsObject['container'][(x + 2) + '/' + y] = 3;

        buildingsObject['link'][x + '/' + y] = 5;

        buildingsObject['spawn'][x + '/' + (y + 2)] = 7;
        buildingsObject['rampart'][x + '/' + (y + 2)] = 7;
        
        let up_container_pos = [];
        for(let x = controller.pos.x - 2;x <= controller.pos.x + 2;x++){
            for(let y = controller.pos.y - 2;y <= controller.pos.y + 2;y++){
                if(Math.abs(x - controller.pos.x) <= 1 && Math.abs(y - controller.pos.y) <= 1)continue;
                let count = 0;
                for(let cx = x - 1;cx <= x + 1;cx++){
                    for(let cy = y - 1;cy <= y + 1;cy++){
                        if(buildingCosts.get(cx,cy) != 255){
                            count++;
                        }
                    }  
                }
                up_container_pos.push([x,y,count]);
            }
        }
        up_container_pos.sort(function(a,b){
            return b[2] - a[2];
        })
        buildingsObject['container'][up_container_pos[0][0] + '/' + up_container_pos[0][1]] = 2;

        buildingsObject['extractor'][mineralPos.x + '/' + mineralPos.y] = 6;
            
        buildingCosts = DM_cost255(buildingCosts,buildingsObject);
    }   
    
    //战略集群
    let strategicCluster = [];
    {
        let strategicCluster_pos = [];
        let distence = 8;
        for(let x = center_energy[0] - distence;x <= center_energy[0] + distence;x++){
            for(let y = center_energy[1] - distence;y <= center_energy[1] + distence;y++){
                if(x < 5 || y < 5 || x >= 45 || y >= 45){
                    continue;
                }
                if(buildingCosts.get(x,y) == 255 
                || DM_XY_Distence(x,y,center_energy[0],center_energy[1]) <= 5
                || DM_XY_Distence(x,y,controller.pos.x,controller.pos.y) <= 3){
                    continue;
                }
                let f = true;
                let sw = 0;
                for(let sx = x - 2; sx <= x + 2;sx++){
                    if(terrain.get(sx,y - 2) == 1){
                        sw++;
                    }
                    if(terrain.get(sx,y + 2) == 1){
                        sw++;
                    }
                }
                for(let sy = y - 2; sy <= y + 2;sy++){
                    if(terrain.get(x - 2,sy) == 1){
                        sw++;
                    }
                    if(terrain.get(x + 2,sy) == 1){
                        sw++;
                    }
                }
                if(sw > 4){
                    continue;
                }
                for(let costs_x = x - 1;costs_x <= x + 1;costs_x++){
                    for(let costs_y = y - 1;costs_y <= y + 1;costs_y++){
                        if(buildingCosts.get(costs_x,costs_y) == 255){
                            f = false;
                            break;
                        }
                    }
                    if(!f)break;
                }
                if(!f)continue;
                for(let source of sources){
                    if(source.pos.getRangeTo(x,y) <= 4){
                        f = false;
                        break;
                    }
                }
                if(!f)continue;
                strategicCluster_pos.push([x,y,DM_XY_Distence(x,y,controller.pos.x,controller.pos.y,true)]);
            }
        }
        if(strategicCluster_pos.length == 0){
            return console.log('中央集群布局失败');
        }
        strategicCluster_pos.sort(function(a,b){
            return a[2] - b[2];
        })
        let x = strategicCluster[0] = strategicCluster_pos[0][0];
        let y = strategicCluster[1] = strategicCluster_pos[0][1];
        let path = PathFinder.search(
            new RoomPosition(x,y,roomName),
            {pos : new RoomPosition(center_energy[0],center_energy[1],roomName),range : 3},
            {
                plainCost : 2,
                swampCost : 10,
                roomCallback:function(){
                    return buildingCosts;
                }
            }
        ).path;
        if(path.length > 10){
            let path_min = [0,0,50]
            for(let i = 1;i < strategicCluster_pos.length;i++){
                let x = strategicCluster_pos[i][0];
                let y = strategicCluster_pos[i][1];
                let path = PathFinder.search(
                    new RoomPosition(x,y,roomName),
                    {pos : new RoomPosition(center_energy[0],center_energy[1],roomName),range : 3},
                    {
                        plainCost : 2,
                        swampCost : 10,
                        roomCallback:function(){
                            return buildingCosts;
                        }
                    }
                ).path;
                if(path.length < path_min[2]){
                    path_min = [x,y,path.length];
                }
            }
            if(path_min[2] < 50){
                x = strategicCluster[0] = path_min[0];
                y = strategicCluster[1] = path_min[1];
            }
        }
        buildingCosts.set(x,y,255);
        for(let i = 0;i < 3;i++){
            if(terrain.get(x - 1 + i,y - 2) != 1){
                buildingsObject['road'][(x - 1 + i) + '/' + (y - 2)] = 4;
            }
            if(terrain.get(x - 1 + i,y + 2) != 1){
                buildingsObject['road'][(x - 1 + i) + '/' + (y + 2)] = 4;
            }
            if(terrain.get(x - 2,y - 1 + i) != 1){
                buildingsObject['road'][(x - 2) + '/' + (y - 1 + i)] = 4;
            }
            if(terrain.get(x + 2,y - 1 + i) != 1){
                buildingsObject['road'][(x + 2) + '/' + (y - 1 + i)] = 4;
            }
        }
        
        let tower_y = y > 25 ? y - 1 : y + 1;
        let storage_x = x > 25 ? x - 1 : x + 1;
        let terminal_x = x > 25 ? x + 1 : x - 1;
        let factory_y = y > 25 ? y + 1 : y - 1;
        buildingsObject['tower'][x + '/' + tower_y] = 3;
        buildingsObject['rampart'][x + '/' + tower_y] = 6;

        buildingsObject['storage'][storage_x + '/' + tower_y] = 4;
        buildingsObject['rampart'][storage_x + '/' + tower_y] = 6;

        buildingsObject['link'][storage_x + '/' + y] = 5;

        buildingsObject['terminal'][terminal_x + '/' + tower_y] = 6;
        buildingsObject['rampart'][terminal_x + '/' + tower_y] = 6;

        buildingsObject['factory'][x + '/' + factory_y] = 7;

        buildingsObject['nuker'][terminal_x + '/' + factory_y] = 8;
        buildingsObject['rampart'][terminal_x + '/' + factory_y] = 8;

        buildingsObject['powerSpawn'][storage_x + '/' + factory_y] = 8;
        buildingsObject['rampart'][storage_x + '/' + factory_y] = 8;

        buildingsObject['spawn'][terminal_x + '/' + y] = 8;
        buildingsObject['rampart'][terminal_x + '/' + y] = 8;
        
        buildingCosts = DM_cost255(buildingCosts,buildingsObject);

    }
    
    //lab
    let labPos = [];
    {
        let distence = 15;
        let lab_pos = [];
        for(let x = center_energy[0] - distence;x <= center_energy[0] + distence;x++){
            for(let y = center_energy[1] - distence;y <= center_energy[1] + distence;y++){
                if(x < 5 || y < 5 || x >= 45 || y >= 45){
                    continue;
                }
                if(buildingCosts.get(x,y) == 255 
                || DM_XY_Distence(x,y,center_energy[0],center_energy[1]) <= 5
                || DM_XY_Distence(x,y,strategicCluster[0],strategicCluster[1]) < 4
                || DM_XY_Distence(x,y,controller.pos.x,controller.pos.y) <= 2){
                    continue;
                }
                let f = true;
                for(let costs_x = x - 2;costs_x <= x + 2;costs_x++){
                    for(let costs_y = y - 2;costs_y <= y + 2;costs_y++){
                        if(buildingCosts.get(costs_x,costs_y) == 255){
                            f = false;
                            break;
                        }
                    }
                    if(!f)break;
                }
                if(!f)continue;
                lab_pos.push([x,y,DM_XY_Distence(x,y,Math.floor((strategicCluster[0] + center_energy[0]) / 2),Math.floor((strategicCluster[1] + center_energy[1]) / 2),true)])
                // visual.rect(x - 0.5,y - 0.5,1,1,{
                //     fill : 'blue'
                // })
            }
        }
        if(lab_pos.length == 0){
            return console.log('lab布局失败');
        }
        lab_pos.sort(function(a,b){
            return a[2] - b[2];
        })
        let labPos_ = [];
        let x = labPos[0] = lab_pos[0][0];
        let y = labPos[1] = lab_pos[0][1];
        buildingsObject['road'][x + '/' + y] = 6;
        if(x < strategicCluster[0]){
            if(y < strategicCluster[1]){
                labPos_[0] = x + '/' + (y - 1);
                labPos_[1] = (x - 1) + '/' + y;
                labPos_[2] = x + '/' + (y + 1);
                buildingsObject['road'][(x - 1) + '/' + (y - 1)] = 6;
                
                labPos_[3] = (x - 1) + '/' + (y + 1);
                labPos_[4] = (x + 1) + '/' + (y - 1);
                labPos_[5] = (x + 1) + '/' + y;
                
                labPos_[6] = (x - 2) + '/' + y;
                labPos_[7] = (x - 2) + '/' + (y - 1);
                labPos_[8] = (x - 1) + '/' + (y - 2);
                labPos_[9] = x + '/' + (y - 2);
            }else{
                labPos_[0] = x + '/' + (y + 1);
                labPos_[1] = (x - 1) + '/' + y;
                labPos_[2] = (x + 1) + '/' + y;
                buildingsObject['road'][(x - 1)+ '/' + (y + 1)] = 6;

                labPos_[3] = (x - 1) + '/' + (y - 1);
                labPos_[4] = (x + 1) + '/' + (y + 1);
                labPos_[5] = x + '/' + (y - 1);

                labPos_[6] = (x - 2) + '/' + y;
                labPos_[7] = (x - 2) + '/' + (y + 1);
                labPos_[8] = (x - 1) + '/' + (y + 2);
                labPos_[9] = x + '/' + (y + 2);
            }
        }else{
            if(y < strategicCluster[1]){
                labPos_[0] = x + '/' + (y - 1);
                labPos_[1] = (x + 1) + '/' + y;
                labPos_[2] = x + '/' + (y + 1);
                buildingsObject['road'][(x + 1) + '/' + (y - 1)] = 6;

                labPos_[3] = (x - 1) + '/' + (y - 1);
                labPos_[4] = (x + 1) + '/' + (y + 1);
                labPos_[5] = (x - 1) + '/' + y;
                
                labPos_[6] = (x + 2) + '/' + y;
                labPos_[7] = (x + 2) + '/' + (y - 1);
                labPos_[8] = (x + 1) + '/' + (y - 2);
                labPos_[9] = x + '/' + (y - 2);
            }else{
                labPos_[0] = x + '/' + (y + 1);
                labPos_[1] = (x + 1) + '/' + y;
                labPos_[2] = x + '/' + (y - 1);
                buildingsObject['road'][(x + 1) + '/' + (y + 1)] = 6;

                labPos_[3] = (x - 1) + '/' + (y + 1);
                labPos_[4] = (x + 1) + '/' + (y - 1);
                labPos_[5] = (x - 1) + '/' + y;

                labPos_[6] = (x + 2) + '/' + y;
                labPos_[7] = (x + 2) + '/' + (y + 1);
                labPos_[8] = (x + 1) + '/' + (y + 2);
                labPos_[9] = x + '/' + (y + 2);
            }
        }
        for(let i = 0;i < 10;i++){
            if(i < 2){
                buildingsObject['rampart'][labPos_[i]] = 8;
            }
            buildingsObject['lab'][labPos_[i]] = i < 3 ? 6 : i < 6 ? 7 : 8;
        }
        buildingCosts = DM_cost255(buildingCosts,buildingsObject);
        
    }
    let extension_3 = 4
    let extension_4 = 10;
    let containerPos = [];
    //能量附近extension
    {
        let extensions_pos = [];
        let linkPos = [];
        sources.forEach(source =>{
            //确定container位置
            let container_pos = [0,0,0];
            for(let x = source.pos.x - 1;x <= source.pos.x + 1;x++){
                for(let y = source.pos.y - 1;y <= source.pos.y + 1;y++){
                    if(terrain.get(x,y) != 1){
                        let count = 0;
                        for(let cx = x - 1;cx <= x + 1;cx++){
                            for(let cy = y - 1;cy <= y + 1;cy++){
                                if(cx == x && cy == y)continue;
                                if(cx <= 1 || cx >= 48 || cy <= 1 || cy >= 48)continue;
                                if(terrain.get(cx,cy) != 1 && buildingCosts.get(x,y) != 255){
                                    count++;
                                }
                            }
                        }
                        if(count > container_pos[2]){
                            container_pos = [x,y,count];
                        }
                    }
                }
            }
            buildingsObject['container'][container_pos[0] + '/' + container_pos[1]] = 3;
            containerPos.push(container_pos);
        })
        if(containerPos.length == 1){
            let needLink = PathFinder.search(
                sources[0].pos,
                new RoomPosition(strategicCluster[0],strategicCluster[1],roomName),
                {
                    plainCost : 2,
                    swampCost : 10,
                    roomCallback:function(){
                        return buildingCosts;
                    }
                }
            ).path.length > 10
            let road_0 = DM_path_sourceContainer_strategicCluster(new RoomPosition(containerPos[0][0],containerPos[0][1],roomName),new RoomPosition(strategicCluster[0],strategicCluster[1],roomName),buildingCosts);
            for(let x = containerPos[0][0] - 1;x <= containerPos[0][0] + 1;x++){
                for(let y = containerPos[0][1] - 1;y <= containerPos[0][1] + 1;y++){
                    if(x == containerPos[0][0] && y == containerPos[0][1])continue;
                    if(x == road_0[0].x && y == road_0[0].y){
                        continue;
                    }
                    if(x <= 1 || y <= 1 || x >= 48 || y >= 48){
                        continue;
                    }
                    if(terrain.get(x,y) != 1 && buildingCosts.get(x,y) != 255 && buildingCosts.get(x,y) != 1){
                        if(needLink && !linkPos[0]){
                            linkPos[0] = [x,y]
                            buildingsObject['link'][x + '/' + y] = 6;
                        }else{
                            extensions_pos.push(x,y);
                            if(extension_3 > 0){
                                buildingsObject['extension'][x + '/' + y] = 3;
                                extension_3--;
                            }else{
                                buildingsObject['extension'][x + '/' + y] = 4;
                                extension_4--;
                            }
                        }
                        buildingCosts.set(x,y,255);                            
                    }
                }   
            }
        }else{
            let container_length = DM_XY_Distence(containerPos[0][0],containerPos[0][1],containerPos[1][0],containerPos[1][1]);
            if(container_length <= 4){
                let path = PathFinder.search(
                    new RoomPosition(containerPos[0][0],containerPos[0][1],roomName),
                    new RoomPosition(containerPos[1][0],containerPos[1][1],roomName),
                    {
                        plainCost: 2,
                        swampCost: 2,
                    }
                ).path;
                if(container_length > 2){
                    for(let pos of path){
                        buildingCosts.set(pos.x,pos.y,255);
                    }
                    path.push(new RoomPosition(containerPos[0][0],containerPos[0][1],roomName));
                    let path_mid = path[Math.floor(path.length / 2) - 1];
                    let link_pos = [];
                    for(let x = path_mid.x - 1;x <= path_mid.x + 1;x++){
                        for(let y = path_mid.y - 1;y <= path_mid.y + 1;y++){
                            if(buildingCosts.get(x,y) == 255 
                            || (x == path_mid.x && y == path_mid.y)
                            || (x == containerPos[0][0] && y == containerPos[0][1])
                            || (x == containerPos[1][0] && y == containerPos[1][1])){
                                continue;
                            }
                            link_pos.push([x,y,DM_XY_Distence(x,y,strategicCluster[0],strategicCluster[1])]);
                        }
                    }
                    link_pos.sort(function(a,b){
                        return a[2] - b[2];
                    })
                    buildingsObject['link'][link_pos[0][0] + '/' + link_pos[0][1]] = 6;
                    linkPos = [link_pos[0][0],link_pos[0][1]];
                }else{
                    let path_mid = path[0];
                    let x = path_mid.x;
                    let y = path_mid.y;
                    buildingsObject['link'][x + '/' + y] = 6;
                    linkPos = [x,y];
                }
                for(let pos of path){
                    buildingCosts.set(pos.x,pos.y,1);
                }
                buildingCosts.set(linkPos[0],linkPos[1],255);
            }
            let road_0 = [];
            let path0 = DM_path_sourceContainer_strategicCluster(new RoomPosition(containerPos[0][0],containerPos[0][1],roomName),new RoomPosition(strategicCluster[0],strategicCluster[1],roomName),buildingCosts);
            let path1 = DM_path_sourceContainer_strategicCluster(new RoomPosition(containerPos[1][0],containerPos[1][1],roomName),new RoomPosition(strategicCluster[0],strategicCluster[1],roomName),buildingCosts);
            road_0[0] = [path0[0].x,path0[0].y];
            road_0[1] = [path1[0].x,path1[0].y];
           
            //确定extension
            for(let i = 0;i < containerPos.length;i++){
                let needLink = PathFinder.search(
                    new RoomPosition(containerPos[i][0],containerPos[i][1],roomName),
                    {pos : new RoomPosition(strategicCluster[0],strategicCluster[1],roomName),range : 2},
                    {
                        plainCost : 2,
                        swampCost : 10,
                        roomCallback:function(){
                            return buildingCosts;
                        }
                    }
                ).path.length > 10;
                for(let x = containerPos[i][0] - 1;x <= containerPos[i][0] + 1;x++){
                    for(let y = containerPos[i][1] - 1;y <= containerPos[i][1] + 1;y++){
                        if(x == containerPos[i][0] && y == containerPos[i][1])continue;
                        if(IsPointBetween([x,y],linkPos, containerPos[i]))continue;
                        if(x == road_0[0][0] && y == road_0[0][1])continue;
                        if(x == road_0[1][0] && y == road_0[1][1])continue;
                        if(x <= 1 || y <= 1 || x >= 48 || y >= 48){
                            continue;
                        }
                        if(terrain.get(x,y) != 1 && buildingCosts.get(x,y) != 255 && buildingCosts.get(x,y) != 1){
                            if(needLink && !linkPos[i]){
                                linkPos[i] = [x,y]
                                buildingsObject['link'][x + '/' + y] = 5 + i;
                            }else{
                                extensions_pos.push(x,y);
                                if(extension_3 > 0){
                                    buildingsObject['extension'][x + '/' + y] = 3;
                                    extension_3--;
                                }else{
                                    buildingsObject['extension'][x + '/' + y] = 4;
                                    extension_4--;
                                }
                            }
                            buildingCosts.set(x,y,255);                            
                        }
                    }   
                }
            }
        }
    }
    //extension
    let distence_extension = 20;
    {
        let extensionPos = [[0,0],[-1,0],[0,1],[1,0],[0,-1]];
        let roadPos = [[-2,0],[-1,-1],[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1]];
        let extensions_pos = [];
        let beginExtensionCount = 10;
        for(let x = center_energy[0] - distence_extension;x <= center_energy[0] + distence_extension;x++){
            for(let y = center_energy[1] - distence_extension;y <= center_energy[1] + distence_extension;y++){
                if(DM_XY_Distence(x,y,controller.pos.x,controller.pos.y) <= 3){
                    continue;
                }
                if(x <= 1 || x >= 48 || y <= 1 || y >= 48){
                    continue;
                }
                let f = true;
                for(let source of sources){
                    if(source.pos.getRangeTo(x,y) < 3){
                        f = false;
                        break
                    }
                }
                if(!f)continue;
                for(let container of containerPos){
                    if(DM_XY_Distence(container[0],container[1],x,y) <= 2){
                        f = false;
                        break;
                    }
                }
                if(!f)continue;
                if(x <= 4){
                    for(let ty = y - 3;ty <= y + 3;ty++){
                        if(terrain.get(0,ty) != 1){
                            f = false;
                            break;
                        }
                    }
                    if(!f)continue;
                }
                if(y <= 4){
                    for(let tx = x - 3;tx <= x + 3;tx++){
                        if(terrain.get(tx,0) != 1){
                            f = false;
                            break;
                        }
                    }
                    if(!f)continue;
                }
                if(x >= 46){
                    for(let ty = y - 3;ty <= y + 3;ty++){
                        if(terrain.get(49,ty) != 1){
                            f = false;
                            break;
                        }
                    }
                    if(!f)continue;
                }
                if(y >= 46){
                    for(let tx = x - 3;tx <= x + 3;tx++){
                        if(terrain.get(tx,49) != 1){
                            f = false;
                            break;
                        }
                    }
                    if(!f)continue;
                }
                for(let extensionPos_ of extensionPos){
                    let cost = buildingCosts.get(extensionPos_[0] + x,extensionPos_[1] + y);
                    if(cost == 255 || cost == 1){
                        f = false;
                        break;
                    }
                }
                if(!f)continue;
                extensions_pos.push([x,y,DM_XY_Distence(x,y,center_energy[0],center_energy[1],true)])
            }
        }

        extensions_pos.sort(function(a,b){
            return a[2] - b[2];
        })
        let beginExtensionLevel = 5;
        let i = 0;
        for(let extensionPos_1 of extensions_pos){
            if(beginExtensionCount == 0){
                beginExtensionLevel++;
                beginExtensionCount = 10;
            }
            if(beginExtensionLevel == 9){
                break;
            }
            let x = extensionPos_1[0];
            let y = extensionPos_1[1];
            let f = true;
            for(let extensionPos_2 of extensionPos){
                let cost = buildingCosts.get(extensionPos_2[0] + x,extensionPos_2[1] + y);
                if(cost == 255 || cost == 1){
                    f = false;
                    break;
                }
            }
            if(!f)continue;
            if((buildingCosts.get(x - 2,y) == 255 && buildingCosts.get(x + 2,y) == 255)
            || (buildingCosts.get(x,y - 2) == 255 && buildingCosts.get(x,y + 2) == 255)
            || (buildingCosts.get(x - 1,y - 1) == 255 && (buildingCosts.get(x - 1,y + 1) == 255 || buildingCosts.get(x + 1,y - 1) == 255 || buildingCosts.get(x + 1,y + 1) == 255 || buildingCosts.get(x + 2,y) == 255 || buildingCosts.get(x,y + 2) == 255))
            || (buildingCosts.get(x - 1,y + 1) == 255 && (buildingCosts.get(x + 1,y + 1) == 255 || buildingCosts.get(x - 1,y - 1) == 255 || buildingCosts.get(x + 1,y - 1) == 255 || buildingCosts.get(x,y - 2) == 255 || buildingCosts.get(x + 2,y) == 255))
            || (buildingCosts.get(x + 1,y - 1) == 255 && (buildingCosts.get(x + 1,y + 1) == 255 || buildingCosts.get(x - 1,y - 1) == 255 || buildingCosts.get(x - 2,y) == 255 || buildingCosts.get(x,y + 2) == 255))
            || (buildingCosts.get(x + 1,y + 1) == 255 && (buildingCosts.get(x + 1,y - 1) == 255 || buildingCosts.get(x - 1,y + 1) == 255 || buildingCosts.get(x - 2,y) == 255 || buildingCosts.get(x,y - 2) == 255))){
                continue;
            }
            let path = PathFinder.search(
                new RoomPosition(x,y,roomName),
                {pos : new RoomPosition(center_energy[0],center_energy[1],roomName),range : 3},
                {
                    plainCost : 2,
                    swampCost : 10,
                    roomCallback:function(){
                        return buildingCosts;
                    }
                }
            ).path;
            if(path.length + 3 > extensionPos_1[2]){
                continue;
            }
            beginExtensionCount -= 5;
            for(let pos of path){
                if(buildingCosts.get(pos.x,pos.y) != 1){
                    buildingsObject['road'][pos.x + '/' + pos.y] = beginExtensionLevel;
                    buildingCosts.set(pos.x , pos.y,1);
                }
            }
            for(let extensionPos_2 of extensionPos){
                buildingsObject['extension'][(x + extensionPos_2[0]) + '/' + (y + extensionPos_2[1])] = beginExtensionLevel;
                buildingCosts.set((x + extensionPos_2[0]) , (y + extensionPos_2[1]),255);
            }
            for(let roadPos_ of roadPos){
                let road_x = x + roadPos_[0];
                let road_y = y + roadPos_[1];
                let cost = buildingCosts.get(road_x,road_y);
                if(cost == 255 || cost == 1)continue;
                if(DM_XY_Distence(road_x,road_y,center_energy[0],center_energy[1]) <= 3)continue;
                buildingsObject['road'][road_x + '/' + road_y] = beginExtensionLevel;
                buildingCosts.set(road_x , road_y,1);
            }
        }
    }
    //能量到中心道路
    {
        let roadCount1 = 0,roadCount2 = 0;
        let path1 = [],path2 = [],pathBest = [];
        let costs1 = new PathFinder.CostMatrix;
        let costs2 = new PathFinder.CostMatrix;
        for(let x = 0;x < 50;x++){
            for(let y = 0;y < 50;y++){
                costs1.set(x,y,buildingCosts.get(x,y));
                costs2.set(x,y,buildingCosts.get(x,y));
            }
        }
        for(let container of containerPos){
            let path = PathFinder.search(
                new RoomPosition(container[0],container[1],roomName),
                {pos : new RoomPosition(center_energy[0],center_energy[1],roomName),range : 3},
                {
                    plainCost : 2,
                    swampCost : 10,
                    roomCallback:function(){
                        return costs1;
                    }
                }
            ).path;
            path1.push(path);
            for(let pos of path){
                if(costs1.get(pos.x,pos.y) != 1)roadCount1++;
                costs1.set(pos.x,pos.y,1);
            }
        }
        let containerPos_ = containerPos.slice().reverse();
        for(let container of containerPos_){
            let path = PathFinder.search(
                new RoomPosition(container[0],container[1],roomName),
                {pos : new RoomPosition(center_energy[0],center_energy[1],roomName),range : 3},
                {
                    plainCost : 2,
                    swampCost : 10,
                    roomCallback:function(){
                        return costs2;
                    }
                }
            ).path;
            path2.push(path);
            for(let pos of path){
                if(costs2.get(pos.x,pos.y) != 1)roadCount2++;
                costs2.set(pos.x,pos.y,1);
            }
        }
        pathBest = roadCount1 <= roadCount2 ? path1 : path2;
        for(let path of pathBest){
            for(let pos of path){
                buildingsObject['road'][pos.x + '/' + pos.y] = 3;
                buildingCosts.set(pos.x,pos.y,1)
            }
        }
        
    }
    //补齐extension
    {
        let extensions_34 = [];
        if(extension_3 > 0 || extension_4 > 0){
            for(let x = center_energy[0] - distence_extension;x <= center_energy[0] + distence_extension;x++){
                for(let y = center_energy[1] - distence_extension;y <= center_energy[1] + distence_extension;y++){
                    let f = true;
                    for(let source of sources){
                        if(source.pos.isNearTo(x,y)){
                            f = false;
                            break;
                        }
                        if(!f)break;
                    }
                    if(!f)continue;
                    let cost = buildingCosts.get(x,y);
                    if(cost == 255 || cost == 1){
                        continue;
                    }
                    if(DM_XY_Distence(x,y,controller.pos.x,controller.pos.y) <= 2){
                        continue;
                    }
                    if(DM_XY_Distence(x,y,center_energy[0],center_energy[1]) <= 3 && cost != 2){
                        continue;
                    }
                    if(x <= 1 || x >= 48 || y <= 1 || y >= 48){
                        continue;
                    }
                    if(x <= 4){
                        for(let ty = y - 3;ty <= y + 3;ty++){
                            if(terrain.get(0,ty) != 1){
                                f = false;
                                break;
                            }
                        }
                        if(!f)continue;
                    }
                    if(y <= 4){
                        for(let tx = x - 3;tx <= x + 3;tx++){
                            if(terrain.get(tx,0) != 1){
                                f = false;
                                break;
                            }
                        }
                        if(!f)continue;
                    }
                    if(x >= 46){
                        for(let ty = y - 3;ty <= y + 3;ty++){
                            if(terrain.get(49,ty) != 1){
                                f = false;
                                break;
                            }
                        }
                        if(!f)continue;
                    }
                    if(y >= 46){
                        for(let tx = x - 3;tx <= x + 3;tx++){
                            if(terrain.get(tx,49) != 1){
                                f = false;
                                break;
                            }
                        }
                        if(!f)continue;
                    }
                    for(let ex = x - 1;ex <= x + 1;ex++){
                        for(let ey = y - 1;ey <= y + 1;ey++){
                            if(buildingCosts.get(ex,ey) == 1){
                                f = false;
                                break;
                            }
                        }
                        if(!f)break;
                    }
                    if(f)continue;
                    extensions_34.push([x,y,DM_XY_Distence(x,y,center_energy[0],center_energy[1],true)])
                }
            }
        }
        extensions_34.sort(function(a,b){
            return a[2] - b[2];
        })
        for(let extensionsPos of extensions_34){
            if(extension_3 > 0){
                buildingsObject['extension'][extensionsPos[0] + '/' + extensionsPos[1]] = 3;
                buildingCosts.set(extensionsPos[0], extensionsPos[1],255);
                extension_3--;
            }else if(extension_4 > 0){
                buildingsObject['extension'][extensionsPos[0] + '/' + extensionsPos[1]] = 4;
                buildingCosts.set(extensionsPos[0], extensionsPos[1],255);
                extension_4--;
            }else break;
        }
    }
    
    //other(战略集群到中心/矿到战略集群/lab到战略集群)
    {
        //战略集群
        let strategicClusterLength = [0,0,50];
        for(let x = strategicCluster[0] - 1;x <= strategicCluster[0] + 1;x++){
            for(let y = strategicCluster[1] - 1;y <= strategicCluster[1] + 1;y++){
                let length = DM_XY_Distence(x,y,center_energy[0],center_energy[1],true);
                if(length < strategicClusterLength[2]){
                    strategicClusterLength = [x,y,length];
                }
            }
        }
        let strategicCluster_center_path = PathFinder.search(
            new RoomPosition(strategicClusterLength[0],strategicClusterLength[1],roomName),
            {pos : new RoomPosition(center_energy[0],center_energy[1],roomName),range : 3},
            {
                plainCost : 2,
                swampCost : 10,
                roomCallback:function(){
                    return buildingCosts;
                }
            }
        ).path;
        for(let i = 1;i < strategicCluster_center_path.length - 1;i++){
            let x = strategicCluster_center_path[i].x;
            let y = strategicCluster_center_path[i].y;
            buildingsObject['road'][x + '/' + y] = 4;
            buildingCosts.set(x,y,1);
        }
        //矿
        let mineral_storage_path = PathFinder.search(
            mineralPos,
            {pos : new RoomPosition(strategicCluster[0],strategicCluster[1],roomName) ,range : 2},
            {
                plainCost : 10,
                swampCost : 50,
                roomCallback:function(){
                    return buildingCosts;
                }
            }
        ).path;
        for(let i = 1;i < mineral_storage_path.length;i++){
            let x = mineral_storage_path[i].x;
            let y = mineral_storage_path[i].y;
            let cost = buildingCosts.get(x,y);
            if(cost != 1 && cost != 3){
                buildingsObject['road'][x + '/' + y] = i == mineral_storage_path.length - 1 ? 4 : 6;
                buildingCosts.set(x,y,1);
            }
        }
        //lab
        let lab_storage_path = PathFinder.search(
            new RoomPosition(labPos[0],labPos[1],roomName),
            {pos : new RoomPosition(strategicCluster[0],strategicCluster[1],roomName),range : 2},
            {
                plainCost : 2,
                swampCost : 10,
                roomCallback:function(){
                    return buildingCosts;
                }
            }
        ).path;
        for(let i = 0;i < lab_storage_path.length;i++){
            let x = lab_storage_path[i].x;
            let y = lab_storage_path[i].y;
            if(buildingCosts.get(x,y) != 1){
                buildingsObject['road'][x + '/' + y] = 6;
                buildingCosts.set(x,y,1);
            }
        }
    }
    //炮台
    {
        let distence = 15;
        let towerPos = [];
        for(let x = center_energy[0] - distence;x <= center_energy[0] + distence;x++){
            for(let y = center_energy[1] - distence;y <= center_energy[1] + distence;y++){
                if(DM_XY_Distence(x,y,controller.pos.x,controller.pos.y) <= 3){
                    continue;
                }
                let cost = buildingCosts.get(x,y);
                if(cost == 255 || cost == 1 || cost == 3){
                    continue;
                }
                if(x <= 4 || y <= 4 || x >= 45 || y >= 45){
                    continue;
                }
                let f = false;
                for(let source of sources){
                    if(source.pos.isNearTo(x,y)){
                        f = true;
                        break;
                    }
                    if(f)break;
                }
                if(f)continue;
                for(let rx = x - 1;rx <= x +1;rx++){
                    for(let ry = y - 1;ry <= y +1;ry++){
                        if(buildingCosts.get(rx,ry) == 1){
                            f = true;
                            break;
                        }
                    }
                    if(f)break;
                }
                if(!f)continue;
                towerPos.push([x,y,DM_XY_Distence(x,y,center_energy[0],center_energy[1],true)])
            }
        }
        towerPos.sort(function(a,b){
            return a[2] - b[2];
        })
        let towerPos_ = [];
        for(let tower of towerPos){
            let x = tower[0];
            let y = tower[1];
            let path = PathFinder.search(
                new RoomPosition(x,y,roomName),
                {pos : new RoomPosition(center_energy[0],center_energy[1],roomName),range : 3},
                {
                    plainCost : 2,
                    swampCost : 10,
                    roomCallback:function(){
                        return buildingCosts;
                    }
                }
            ).path;
            if(path.length < 10){
                towerPos_.push([x,y]);
            }
        }
        towerPos = towerPos_;
        buildingsObject['tower'][towerPos[0][0] + '/' + towerPos[0][1]] = 5;
        buildingsObject['tower'][towerPos[1][0] + '/' + towerPos[1][1]] = 7;
        buildingsObject['tower'][towerPos[2][0] + '/' + towerPos[2][1]] = 8;
        buildingsObject['tower'][towerPos[3][0] + '/' + towerPos[3][1]] = 8;
        buildingsObject['tower'][towerPos[4][0] + '/' + towerPos[4][1]] = 8;
        buildingsObject['rampart'][towerPos[0][0] + '/' + towerPos[0][1]] = 5;
        buildingsObject['rampart'][towerPos[1][0] + '/' + towerPos[1][1]] = 7;
        buildingsObject['rampart'][towerPos[2][0] + '/' + towerPos[2][1]] = 8;
        buildingsObject['rampart'][towerPos[3][0] + '/' + towerPos[3][1]] = 8;
        buildingsObject['rampart'][towerPos[4][0] + '/' + towerPos[4][1]] = 8;
        buildingCosts = DM_cost255(buildingCosts,buildingsObject);
    }
    Memory.rooms[roomName]['buildings'] = buildingsObject;

    VisualBuilding(buildingCosts,false);
}
function Visual(costs){
    return;
    let visual = new RoomVisual(roomName);
    let color;
    for(let x = 0;x < 50;x++){
        for(let y = 0;y < 50;y++){
            switch(costs.get(x,y)){
                case 250 :
                    color = '#ffffff';
                    break;
                case 251 :
                    color = '#300000';
                    break;
                case 252 :
                    color = '#005000';
                    break;
                default :
                    continue;
            }
            visual.rect(x - 0.5,y - 0.5,1,1,{
                fill : color,
                opacity : 0.3
            })
        }
    }
}
function DM_path_sourceContainer_strategicCluster(container,center,costs){
    return PathFinder.search(
        container,
        {pos : center,range : 2},
        {
            plainCost: 2,
            swampCost: 10,
            roomCallback: function() {
                return costs;
            }
        }
    ).path;
}
function DM_cost255(costs,buildings){
    for(let type in buildings){
        if(type == 'rampart')continue;
        for(let str in buildings[type]){
            let pos = str.split('/');
            costs.set(parseInt(pos[0]),parseInt(pos[1]),type == 'road' ? 1 : type == 'container' ? 3 : 255);
        }
    }
    return costs;
}
function VisualBuilding(buildingCosts,bool){
    if(v){
        return Game.rooms[roomName].visual.import(v);
    }
    let buildings = Memory.rooms[roomName]['buildings'];
    let visual = new RoomVisual(roomName);
    for(let type in buildings){
        if(type == 'rampart')continue;
        for(let str in buildings[type]){
            let pos = str.split('/');
            let x = parseInt(pos[0]);
            let y = parseInt(pos[1]);
            switch (type) {
                case 'spawn':
                    visual.circle(x, y, { fill: 'white', radius: 0.65, opacity: 0.6 })
                    visual.circle(x, y, { fill: 'black', radius: 0.55, opacity: 0.8 })
                    visual.circle(x, y, { fill: 'yellow', radius: 0.35, opacity: 0.8 })
                    break;
                case 'extension':
                    visual.circle(x, y, { fill: 'green', radius: 0.4, opacity: 0.7 })
                    visual.circle(x, y, { fill: 'black', radius: 0.35, opacity: 0.7 })
                    visual.circle(x, y, { fill: 'yellow', radius: 0.3, opacity: 0.7 })
                    break;
                case 'link':
                    visual.poly([[x, y - 0.45], [x - 0.35, y], [x, y + 0.45], [x + 0.35, y], [x, y - 0.45], [x - 0.35, y]]
                        , { stroke: 'green', opacity: 0.8, strokeWidth: 0.07 })
                    visual.poly([[x, y - 0.3], [x - 0.25, y], [x, y + 0.3], [x + 0.25, y], [x, y - 0.3], [x - 0.25, y]]
                        , { stroke: 'black', opacity: 0.8, strokeWidth: 0.07, fill: 'grey' })
                    break;
                case 'road':
                    visual.circle(x, y, { fill: 'orange', radius: 0.2, opacity: 0.8 })
                    break;
                case 'constructedWall':
                    visual.circle(x, y, { fill: 'black', radius: 0.5, opacity: 0.6 })
                    break;
                case 'storage':
                    visual.rect(x - 0.5, y - 0.7, 1, 1.4, { stroke: 'green', fill: 'black', opacity: 0.8 })
                    visual.rect(x - 0.4, y - 0.5, 0.8, 0.5, { fill: 'grey', opacity: 0.8 })
                    visual.rect(x - 0.4, y, 0.8, 0.5, { fill: 'yellow', opacity: 0.8 })
                    break;
                case 'observer':
                    visual.circle(x, y, { fill: 'green', radius: 0.5, opacity: 0.8 })
                    visual.circle(x, y, { fill: 'black', radius: 0.45, opacity: 1 })
                    visual.circle(x + 0.2, y, { fill: 'green', radius: 0.25, opacity: 0.8 })
                    break;
                case 'powerSpawn':
                    visual.circle(x, y, { fill: 'white', radius: 0.8, opacity: 0.6 })
                    visual.circle(x, y, { fill: 'red', radius: 0.75, opacity: 0.8 })
                    visual.circle(x, y, { fill: 'black', radius: 0.65, opacity: 0.8 })
                    visual.circle(x, y, { fill: 'red', radius: 0.4, opacity: 0.8 })
                    break;
                case 'extractor':
                    visual.circle(x, y, { stroke: 'green', strokeWidth: 0.2, radius: 0.74, fill: false, lineStyle: 'dashed' })
                    break;
                case 'terminal':
                    visual.poly([[x, y - 0.85], [x - 0.5, y - 0.5], [x - 0.85, y], [x - 0.5, y + 0.5], [x, y + 0.85], [x + 0.5, y + 0.5], [x + 0.85, y], [x + 0.5, y - 0.5], [x, y - 0.85], [x - 0.5, y - 0.5]]
                        , { stroke: 'green', opacity: 1, strokeWidth: 0.07 })
                    visual.poly([[x, y - 0.75], [x - 0.45, y - 0.45], [x - 0.75, y], [x - 0.45, y + 0.45], [x, y + 0.75], [x + 0.45, y + 0.45], [x + 0.75, y], [x + 0.45, y - 0.45], [x, y - 0.75], [x - 0.45, y - 0.45]]
                        , { fill: 'grey', stroke: 'black', opacity: 1, strokeWidth: 0.07 })
                    visual.rect(x - 0.4, y - 0.4, 0.8, 0.8, { stroke: 'black', strokeWidth: 0.1, fill: 'yellow', opacity: 0.8 })
                    break;
                case 'lab':
                    visual.circle(x, y, { fill: 'green', radius: 0.5, opacity: 0.8 })
                    visual.rect(x - 0.4, y + 0.2, 0.8, 0.3, { fill: 'green', opacity: 0.8 })
                    visual.circle(x, y, { fill: 'black', radius: 0.45, opacity: 0.8 })
                    visual.circle(x, y, { fill: 'white', radius: 0.35, opacity: 0.8 })
                    visual.rect(x - 0.35, y + 0.25, 0.7, 0.2, { fill: 'black', opacity: 0.8 })
                    visual.rect(x - 0.2, y + 0.3, 0.4, 0.1, { fill: 'yellow', opacity: 0.8 })
                    break;
                case 'container':
                    visual.rect(x - 0.25, y - 0.3, 0.5, 0.6, { stroke: 'black', strokeWidth: 0.1, fill: 'yellow', opacity: 0.8 })
                    break;
                case 'nuker':
                    visual.poly([[x, y - 1.5], [x - 0.7, y], [x - 0.7, y + 0.7], [x + 0.7, y + 0.7], [x + 0.7, y], [x, y - 1.5], [x - 0.7, y]]
                        , { stroke: 'green', opacity: 0.8, strokeWidth: 0.2 })
                    visual.poly([[x, y - 1.3], [x - 0.6, y], [x - 0.6, y + 0.6], [x + 0.6, y + 0.6], [x + 0.6, y], [x, y - 1.3], [x - 0.6, y], [x + 0.6, y]]
                        , { stroke: 'black', opacity: 0.8, strokeWidth: 0.2, fill: 'grey' })
                    break;
                case 'factory':
                    visual.circle(x, y, { fill: 'black', radius: 0.6, opacity: 1 })
                    visual.line(x - 0.2, y - 0.8, x - 0.2, y + 0.8, { color: 'black', opacity: 0.8 })
                    visual.line(x + 0.2, y - 0.8, x + 0.2, y + 0.8, { color: 'black', opacity: 0.8 })
                    visual.line(x - 0.8, y - 0.2, x + 0.8, y - 0.2, { color: 'black', opacity: 0.8 })
                    visual.line(x - 0.8, y + 0.2, x + 0.8, y + 0.2, { color: 'black', opacity: 0.8 })
                    break;
                case 'tower':
                    visual.circle(x, y, { stroke: 'green', fill: false, radius: 0.6, opacity: 0.8 })
                    visual.circle(x, y, { fill: 'black', radius: 0.55, opacity: 0.9 })
                    visual.rect(x - 0.35, y - 0.25, 0.7, 0.5, { fill: 'grey', opacity: 0.8 })
                    visual.rect(x - 0.25, y - 0.85, 0.5, 0.6, { fill: 'black', opacity: 0.8 })
                    visual.rect(x - 0.2, y - 0.8, 0.4, 0.5, { fill: 'grey', opacity: 0.8 })
                    break;
            }
        }
    }
    for(let str in buildings['rampart']){
        let pos = str.split('/');
        visual.rect(parseInt(pos[0]) - 0.5, parseInt(pos[1]) - 0.5, 1, 1, { stroke: 'green', fill: 'green', opacity: 0.3 })
    }
    for(let type in buildings){
        for(let str in buildings[type]){
            let level = buildings[type][str];
            let pos = str.split('/');
            let x = parseInt(pos[0]);
            let y = parseInt(pos[1]);
            visual.text(level,x + 0.4,type == 'rampart' ? y + 0.2 : y + 0.5,{
                font : 0.3
            })
        }
    }
    if(bool){
        for(let x = 0;x < 50;x++){
            for(let y = 0;y < 50;y++){
                visual.text(buildingCosts.get(x,y),x ,y + 0.45 ,{
                    font : 0.2,
                    color : 'yellow'
                })
            }
        }
    }
    v = Game.rooms[roomName].visual.export();
}
function DM_XY_Distence(x1,y1,x2,y2,bool){
    if(bool){
        return Math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2) * (y1 - y2));
    }else{
        return Math.max(Math.abs(x1 - x2),Math.abs(y1 - y2));
    }
}
function IsPointBetween(point, point1, point2) {
    var minX = Math.min(point1[0], point2[0]);
    var maxX = Math.max(point1[0], point2[0]);
    var minY = Math.min(point1[1], point2[1]);
    var maxY = Math.max(point1[1], point2[1]);
    return (point[0] > minX && point[0] < maxX && point[1] > minY && point[1] < maxY);
}
  